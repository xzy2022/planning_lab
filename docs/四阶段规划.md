
## 四阶段的规划

这是一个非常好的思路！在 Agent Manager 的工作模式下，**“拆解（Decomposition）”**是第一要务。我们不能把一个巨大的任务扔给 AI，而是要将其拆解为一系列可验证、可测试的“里程碑（Milestones）”。

基于你的作业要求和你目前的代码基础，我为你设计了一个**四阶段实施方案**。这个方案不仅符合软件工程的迭代逻辑，也能让你在每个阶段都有可视化的成果来撰写实验报告。

---

### 📅 阶段一：全局运动规划基线 (The Kinematic Baseline)

**目标**：在全知地图下，确保基于阿克曼模型的 RRT 能够跑通，并产生符合运动学的路径。这是所有后续工作的基础。

* **核心逻辑**：
* 目前的 `RRTPlanner` 已经通过 `vehicle.propagate_towards` 接口支持了阿克曼模型。
* 但需要验证：生成的路径是否真的平滑？在死胡同（Generator 已生成）中是否会被卡住？


* **Agent 任务拆解**：
1. **[验证] 运动学 RRT 单元测试**：编写一个专门的测试脚本，强制使用 `AckermannVehicle` + `RRTPlanner`。重点观察生成的路径是否真的是曲线（符合转向限制），而不是折线。
2. **[优化] 转向策略调优**：目前的 `propagate_towards` 使用的是贪心策略（直接转向目标点）。如果 RRT 在障碍物密集区表现不好，可能需要调整 `step_size`（步长）或者引入简单的倒车逻辑（虽然大作业通常只要求前进）。
3. **[可视化] 轨迹检查**：确保可视化工具能画出带有方向（Heading）的车辆 footprint，而不仅仅是点。



### 📅 阶段二：路径平滑与优化 (Optimization Layer)

**目标**：解决 RRT 路径“抖动”和“绕路”的问题，完成作业要求中的“基于优化的平滑”。

* **核心逻辑**：
* RRT 的随机性会导致路径有很多不必要的“之”字形。
* 对于阿克曼小车，不能简单地把点连成直线（因为车不能横着走）。


* **Agent 任务拆解**：
1. **[新增] 贪心剪枝平滑器 (Greedy Shortcut Smoother)**：
* 算法：随机选取路径上的两个点  和 ，尝试用车辆的运动学模型（`propagate_towards`）直接连接。如果无碰撞，则剔除中间的节点。
* 注意：必须使用车辆的运动学推演来连接，不能用直线。


2. **[进阶/可选] B样条平滑 (B-Spline)**：如果不满足于剪枝，可以引入 `scipy.interpolate` 对路径点进行拟合，但需要重新进行碰撞检测验证。
3. **[集成] Pipeline 封装**：在 `PlannerBase` 中增加 `post_process` 接口，将平滑作为规划后的自动步骤。



### 📅 阶段三：动态仿真与局部感知 (Simulation Loop)

**目标**：完成作业的核心难点——**Task 2（局部感知与重规划）**。从“上帝视角”转变为“驾驶员视角”。

* **核心逻辑**：
* 你需要构建一个时间步（Time-stepping）仿真器。
* 维护两张图：`GlobalMap`（真实环境，用于碰撞检测和生成传感器数据）和 `LocalMap`（车辆认知地图，用于规划）。


* **Agent 任务拆解**：
1. **[架构] 仿真主循环 (Navigator Class)**：
* 实现 `while not reached_goal:` 循环。
* 实现 `Sense -> Plan/Replan -> Move` 的状态机。


2. **[功能] 模拟激光雷达/传感器**：
* 实现一个函数 `scan_environment(true_map, vehicle_state, radius=30)`，将真实地图中半径 30m 内的障碍物“复制”到认知地图中。


3. **[逻辑] 乐观规划策略 (Optimistic Planning)**：
* 在认知地图中，未知区域默认为“可行”。
* 当车辆移动发现新障碍物阻挡了当前路径时，触发 `replan()`。





### 📅 阶段四：混合 A* 与 算法对比 (Advanced Planning & Comparison)

**目标**：提升规划质量，满足“实验要求 1 & 3”（不同算法对比）。

* **核心逻辑**：
* 普通的 A*（你现有的）只能生成几何路径，无法直接用于阿克曼底盘的导航（除非做为下层参考）。
* **Hybrid A*** 是工业界标准做法，它在栅格搜索的同时考虑车辆航向（x, y, theta）。


* **Agent 任务拆解**：
1. **[重构] 混合 A* 节点设计**：
* 将 A* 的 Node 从 `(x, y)` 扩展为 `(x, y, theta_discrete)`（例如将航向分为 72 个离散方向）。


2. **[核心] 运动原语扩展 (Motion Primitives)**：
* 在 `expand_node` 时，不再是访问 8 个邻居格子，而是模拟车辆“左转、直行、右转”一段距离，生成 3 个子节点。


3. **[启发式] Reed-Shepp 曲线（可选）**：
* 如果时间允许，引入 Reed-Shepp 曲线作为 Heuristic（你已经上传了相关文件框架），这将极大提升 A* 的效率。


4. **[分析] 批量测试**：
* 使用 `benchmark_runner.py` 对比 RRT（阶段一）、平滑 RRT（阶段二）和 Hybrid A*（阶段四）在不同密度下的成功率和路径长度。




